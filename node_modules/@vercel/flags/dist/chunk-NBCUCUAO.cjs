"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/crypto.ts
var _jose = require('jose');
async function encryptJWT(payload, expirationTime, secret) {
  return new (0, _jose.EncryptJWT)(payload).setExpirationTime(expirationTime).setProtectedHeader({ alg: "dir", enc: "A256GCM" }).encrypt(_jose.base64url.decode(secret));
}
async function decryptJWT(cookie, verify, secret) {
  if (typeof cookie !== "string")
    return;
  try {
    const { payload } = await _jose.jwtDecrypt.call(void 0, cookie, _jose.base64url.decode(secret));
    const decoded = payload;
    if (!verify || verify(decoded)) {
      delete decoded.iat;
      delete decoded.exp;
      return decoded;
    }
  } catch (e) {
  }
}

// src/index.ts
function safeJsonStringify(value, replacer, space) {
  return JSON.stringify(value, replacer, space).replace(/</g, "\\u003c");
}
async function encrypt(value, secret = _optionalChain([process, 'optionalAccess', _ => _.env, 'optionalAccess', _2 => _2.FLAGS_SECRET])) {
  if (!secret)
    throw new Error("Missing FLAGS_SECRET");
  return encryptJWT({ c: value }, "1y", secret);
}
async function decrypt(encryptedData, secret = _optionalChain([process, 'optionalAccess', _3 => _3.env, 'optionalAccess', _4 => _4.FLAGS_SECRET])) {
  if (!secret)
    throw new Error("Missing FLAGS_SECRET");
  const content = await decryptJWT(encryptedData, null, secret);
  return _optionalChain([content, 'optionalAccess', _5 => _5.c]);
}
async function verifyAccess(authHeader, secret = _optionalChain([process, 'optionalAccess', _6 => _6.env, 'optionalAccess', _7 => _7.FLAGS_SECRET])) {
  if (!authHeader)
    return false;
  const data = await decrypt(_optionalChain([authHeader, 'optionalAccess', _8 => _8.replace, 'call', _9 => _9(/^Bearer /i, "")]), secret);
  return data !== void 0;
}
function reportValue(key, value) {
  const symbol = Symbol.for("@vercel/request-context");
  const ctx = _optionalChain([Reflect, 'access', _10 => _10.get, 'call', _11 => _11(globalThis, symbol), 'optionalAccess', _12 => _12.get, 'call', _13 => _13()]);
  _optionalChain([ctx, 'optionalAccess', _14 => _14.flags, 'optionalAccess', _15 => _15.reportValue, 'call', _16 => _16(key, value)]);
}







exports.safeJsonStringify = safeJsonStringify; exports.encrypt = encrypt; exports.decrypt = decrypt; exports.verifyAccess = verifyAccess; exports.reportValue = reportValue;
//# sourceMappingURL=chunk-NBCUCUAO.cjs.map