import {
  decrypt,
  encrypt,
  reportValue,
  safeJsonStringify,
  verifyAccess
} from "../chunk-7GGUAVU6.js";

// src/sveltekit/index.ts
import { AsyncLocalStorage } from "node:async_hooks";
function hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty(prop);
}
async function resolveObjectPromises(obj) {
  const entries = Object.entries(obj);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, promise]) => {
      const value = await promise;
      return [key, value];
    })
  );
  return Object.fromEntries(resolvedEntries);
}
function flag(definition) {
  const flagImpl = async function flagImpl2() {
    const store = flagStorage.getStore();
    if (!store) {
      throw new Error("@vercel/flags: context not found");
    }
    if (hasOwnProperty(store.usedFlags, definition.key)) {
      const valuePromise2 = store.usedFlags[definition.key];
      if (typeof valuePromise2 !== "undefined") {
        return valuePromise2;
      }
    }
    const overridesCookie = store.event.cookies.get("vercel-flag-overrides");
    const overrides = overridesCookie ? await decrypt(overridesCookie, store.secret) : void 0;
    if (overrides && hasOwnProperty(overrides, definition.key)) {
      const value2 = overrides[definition.key];
      if (typeof value2 !== "undefined") {
        reportValue(definition.key, value2);
        store.usedFlags[definition.key] = Promise.resolve(value2);
        return value2;
      }
    }
    const valuePromise = definition.decide(store.event);
    store.usedFlags[definition.key] = valuePromise;
    const value = await valuePromise;
    reportValue(definition.key, value);
    return value;
  };
  flagImpl.key = definition.key;
  flagImpl.description = definition.description;
  flagImpl.options = definition.options;
  flagImpl.origin = definition.origin;
  return flagImpl;
}
function getProviderData(flags) {
  const definitions = Object.values(flags).reduce(
    (acc, d) => {
      acc[d.key] = {
        options: d.options,
        origin: d.origin,
        description: d.description
      };
      return acc;
    },
    {}
  );
  return { definitions, hints: [] };
}
function createContext(event, secret) {
  return {
    event,
    secret,
    usedFlags: {}
  };
}
var flagStorage = new AsyncLocalStorage();
function createHandle({
  secret,
  flags
}) {
  return function handle({ event, resolve }) {
    if (flags && // avoid creating the URL object for every request by checking with includes() first
    event.request.url.includes("/.well-known/") && new URL(event.request.url).pathname === "/.well-known/vercel/flags") {
      return handleWellKnownFlagsRoute(event, secret, flags);
    }
    const flagContext = createContext(event, secret);
    return flagStorage.run(
      flagContext,
      () => resolve(event, {
        transformPageChunk: async ({ html }) => {
          const store = flagStorage.getStore();
          if (!store || Object.keys(store.usedFlags).length === 0)
            return html;
          const encryptedFlagValues = await encrypt(
            await resolveObjectPromises(store.usedFlags),
            secret
          );
          return html.replace(
            "</body>",
            `<script type="application/json" data-flag-values>${safeJsonStringify(encryptedFlagValues)}</script></body>`
          );
        }
      })
    );
  };
}
async function handleWellKnownFlagsRoute(event, secret, flags) {
  const access = await verifyAccess(
    event.request.headers.get("Authorization"),
    secret
  );
  if (!access)
    return new Response(null, { status: 401 });
  return Response.json(getProviderData(flags));
}
export {
  createHandle,
  flag,
  getProviderData
};
//# sourceMappingURL=index.js.map