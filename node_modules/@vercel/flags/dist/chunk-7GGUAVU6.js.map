{"version":3,"sources":["../src/crypto.ts","../src/index.ts"],"sourcesContent":["import { jwtDecrypt, base64url, EncryptJWT } from 'jose';\n\nexport async function encryptJWT<T extends object = Record<string, unknown>>(\n  payload: T,\n  expirationTime: string,\n  secret: string,\n): Promise<string> {\n  return new EncryptJWT(payload as Record<string, unknown>)\n    .setExpirationTime(expirationTime)\n    .setProtectedHeader({ alg: 'dir', enc: 'A256GCM' })\n    .encrypt(base64url.decode(secret));\n}\n\nexport async function decryptJWT<\n  T extends string | object = Record<string, unknown>,\n>(\n  cookie: string,\n  verify: undefined | null | ((payload: T) => boolean),\n  secret: string,\n): Promise<T | undefined> {\n  if (typeof cookie !== 'string') return;\n\n  try {\n    const { payload } = await jwtDecrypt(cookie, base64url.decode(secret));\n    const decoded = payload as T;\n\n    if (!verify || verify(decoded)) {\n      // @ts-expect-error jwt field\n      delete decoded.iat;\n      // @ts-expect-error jwt field\n      delete decoded.exp;\n      return decoded;\n    }\n  } catch {\n    // Do nothing\n  }\n}\n","import { encryptJWT, decryptJWT } from './crypto';\nimport { ProviderData } from './providers/types';\n\nexport type { ProviderData } from './providers/types';\n\n/**\n * Data returned by the .well-known/vercel/flags API Route which the toolbar understands.\n */\nexport type ApiData = {\n  /**\n   * Metadata about your application's feature flags\n   */\n  definitions?: FlagDefinitionsType;\n  /**\n   * Hints show up in the toolbar. They are meant to be used in case loading\n   * data from your flag provider fails. For example when the provider fails to\n   * responed or the configuration is invalid due to a missing environment variable.\n   */\n  hints?: ProviderData['hints'];\n  /**\n   * Sets the encryption mode for the vercel-flag-overrides cookie\n   * - when set to \"encrypted\" the toolbar will store encrypted overrides\n   * - when set to \"plaintext\" the toolbar will store plaintext overrides\n   */\n  overrideEncryptionMode?: 'encrypted' | 'plaintext';\n};\n\ntype JsonArray = ReadonlyArray<JsonValue>;\nexport type JsonValue =\n  | string\n  | boolean\n  | number\n  | null\n  | JsonArray\n  | { [key: string]: JsonValue };\n\ninterface FlagOptionType {\n  value: JsonValue;\n  label?: string;\n}\n\nexport interface FlagDefinitionType {\n  options?: FlagOptionType[];\n  /**\n   * The URL where the feature flag can be managed.\n   */\n  origin?: string;\n  description?: string;\n}\n\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * This function is just like JSON.stringify but also escapes the resulting string to prevent XSS.\n *\n * @see https://pragmaticwebsecurity.com/articles/spasecurity/json-stringify-xss\n * @param value A JavaScript value, usually an object or array, to be converted.\n * @param replacer A function that transforms the results.\n * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n */\nexport function safeJsonStringify(\n  value: any,\n  replacer?: (this: any, key: string, value: any) => any,\n  space?: string | number,\n): string;\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * This function is just like JSON.stringify but also escapes the resulting string to prevent XSS.\n *\n * @see https://pragmaticwebsecurity.com/articles/spasecurity/json-stringify-xss\n * @param value A JavaScript value, usually an object or array, to be converted.\n * @param replacer An array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.\n * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n */\nexport function safeJsonStringify(\n  value: any,\n  replacer?: (number | string)[] | null,\n  space?: string | number,\n): string;\n\nexport function safeJsonStringify(\n  value: any,\n  replacer: any,\n  space: any,\n): string {\n  return JSON.stringify(value, replacer, space).replace(/</g, '\\\\u003c');\n}\n\n/**\n * Definitions of a feature flags.\n *\n * Definitions are data like the description, available options, or its origin.\n */\nexport type FlagDefinitionsType = Record<string, FlagDefinitionType>;\n\n/**\n * Values of feature flags.\n *\n * This record consists of key-value pairs of flag keys and the value they resolved to.\n */\nexport type FlagValuesType = Record<string, JsonValue>;\n\n/**\n * Overrides of feature flags.\n *\n * This record consists of key-value pairs of flag keys and the override to be used for them.\n */\nexport type FlagOverridesType = Record<string, JsonValue>;\n\n/**\n * Function to encrypt overrides, values, definitions, and API data.\n */\nexport async function encrypt<T extends object>(\n  value: T,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n): Promise<string> {\n  if (!secret) throw new Error('Missing FLAGS_SECRET');\n  // Encapsule the data within the `c` (content) property to avoid conflicts\n  // with other JWT properties like `iat` and `exp`.\n  return encryptJWT({ c: value }, '1y', secret);\n}\n\n/**\n * Function to decrypt overrides, values, definitions, and API data.\n */\nexport async function decrypt<T extends object>(\n  encryptedData: string,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n): Promise<T | undefined> {\n  if (!secret) throw new Error('Missing FLAGS_SECRET');\n  const content = await decryptJWT<{ c: T }>(encryptedData, null, secret);\n  return content?.c;\n}\n\n/**\n * This function lets you verify whether a request to your application's .well-known/vercel/flags endpoint was made by the toolbar.\n * You can use verifyAccess to keep this endpoint private, to avoid public access of your feature flag definitions through that endpoint.\n *\n * @example Using verifyAccess in .well-known/vercel/flags to verify access and respond with unencrypted data.\n * ```\n *  import { type NextRequest, NextResponse } from \"next/server\";\n *  import { verifyAccess } from \"@vercel/flags\";\n *\n *  export async function GET(request: NextRequest) {\n *    const access = await verifyAccess(request.headers.get(\"Authorization\"));\n *    if (!access) return NextResponse.json(null, { status: 401 });\n *\n *    return NextResponse.json({ definitions: {} })\n *  }\n * ```\n * @param authHeader the Authorization header to check\n * @param secret the FLAGS_SECRET\n * @returns True when the authorization header was valid\n */\nexport async function verifyAccess(\n  // App Router returns null when a header is not defined\n  // Pages Router returns undefined when a header is not defined\n  // We support both so the API is slim in both cases\n  authHeader: string | null | undefined,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n) {\n  if (!authHeader) return false;\n  const data = await decrypt<{}>(authHeader?.replace(/^Bearer /i, ''), secret);\n  return data !== undefined;\n}\n\n/**\n * This function lets you report the value of a resolved flag, which will make it available when viewing Monitoring, Logs, Analytics and Speed Insights on Vercel.\n * It's important to note that this only has effects when running on Vercel in a preview or production environments, but not during local development.\n *\n * @example Using `reportValue` to report a flag value.\n * ```\n *  import { type NextRequest, NextResponse } from \"next/server\";\n *  import { reportValue } from '@vercel/flags';\n *\n *  export async function GET(request: NextRequest) {\n *    reportValue('my-flag', true);\n *    return NextResponse.json({});\n *  }\n * ```\n *\n * @param key the name of the flag\n * @param value the resolved value of the flag\n */\nexport function reportValue(key: string, value: unknown) {\n  const symbol = Symbol.for('@vercel/request-context');\n  const ctx = Reflect.get(globalThis, symbol)?.get();\n  ctx?.flags?.reportValue(key, value);\n}\n"],"mappings":";AAAA,SAAS,YAAY,WAAW,kBAAkB;AAElD,eAAsB,WACpB,SACA,gBACA,QACiB;AACjB,SAAO,IAAI,WAAW,OAAkC,EACrD,kBAAkB,cAAc,EAChC,mBAAmB,EAAE,KAAK,OAAO,KAAK,UAAU,CAAC,EACjD,QAAQ,UAAU,OAAO,MAAM,CAAC;AACrC;AAEA,eAAsB,WAGpB,QACA,QACA,QACwB;AACxB,MAAI,OAAO,WAAW;AAAU;AAEhC,MAAI;AACF,UAAM,EAAE,QAAQ,IAAI,MAAM,WAAW,QAAQ,UAAU,OAAO,MAAM,CAAC;AACrE,UAAM,UAAU;AAEhB,QAAI,CAAC,UAAU,OAAO,OAAO,GAAG;AAE9B,aAAO,QAAQ;AAEf,aAAO,QAAQ;AACf,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AAAA,EAER;AACF;;;AC6CO,SAAS,kBACd,OACA,UACA,OACQ;AACR,SAAO,KAAK,UAAU,OAAO,UAAU,KAAK,EAAE,QAAQ,MAAM,SAAS;AACvE;AA0BA,eAAsB,QACpB,OACA,SAA6B,SAAS,KAAK,cAC1B;AACjB,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,sBAAsB;AAGnD,SAAO,WAAW,EAAE,GAAG,MAAM,GAAG,MAAM,MAAM;AAC9C;AAKA,eAAsB,QACpB,eACA,SAA6B,SAAS,KAAK,cACnB;AACxB,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,sBAAsB;AACnD,QAAM,UAAU,MAAM,WAAqB,eAAe,MAAM,MAAM;AACtE,SAAO,SAAS;AAClB;AAsBA,eAAsB,aAIpB,YACA,SAA6B,SAAS,KAAK,cAC3C;AACA,MAAI,CAAC;AAAY,WAAO;AACxB,QAAM,OAAO,MAAM,QAAY,YAAY,QAAQ,aAAa,EAAE,GAAG,MAAM;AAC3E,SAAO,SAAS;AAClB;AAoBO,SAAS,YAAY,KAAa,OAAgB;AACvD,QAAM,SAAS,OAAO,IAAI,yBAAyB;AACnD,QAAM,MAAM,QAAQ,IAAI,YAAY,MAAM,GAAG,IAAI;AACjD,OAAK,OAAO,YAAY,KAAK,KAAK;AACpC;","names":[]}