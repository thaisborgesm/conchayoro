import { JsonValue, ProviderData, FlagDefinitionType } from '../index.js';
import { ReadonlyHeaders } from 'next/dist/server/web/spec-extension/adapters/headers';
import { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies';

type GenerousOption<T> = boolean extends T ? boolean | FlagOption<T> : T extends string | number ? T | FlagOption<T> : FlagOption<T>;
type FlagOption<T> = {
    value: T;
    label?: string;
};
type Decide<T> = (params: {
    headers: ReadonlyHeaders;
    cookies: ReadonlyRequestCookies;
}) => Promise<T> | T;
type FlagDeclaration<T> = {
    /**
     * The key of the feature flag
     */
    key: string;
    /**
     * An optional defaultValue which will be used when the flag's `decide` function returns undefined or throws an error. Catches async errors too.
     */
    defaultValue?: T;
    /**
     * A URL where this feature flag can be managed. Will show up in Vercel Toolbar.
     */
    origin?: string;
    /**
     * A description of this feature flag. Will show up in Vercel Toolbar.
     */
    description?: string;
    /**
     * An array containing available options.
     *
     * The returend value does not need to be declared in `options`, but it's recommended as all declared options show up in Vercel Toolbar.
     *
     * Value is required, but the label is optional.
     * @example `[{ label: "Off", value: false }, { label: "On", value: true }]`
     *
     * Non-objects like strings can be passed using shorthands which will be used as values without labels.
     * @example `["EUR", "USD"]`
     */
    options?: GenerousOption<T>[];
    /**
     * This function is called when the feature flag is used (and no override is present) to return a value.
     */
    decide: Decide<T>;
};
type FlagMeta<T> = {
    /**
     * The key of the feature flag
     */
    key: string;
    /**
     * An optional defaultValue which will be used when the flag's `decide` function returns undefined or throws an error. Catches async errors too.
     */
    defaultValue?: T;
    /**
     * A URL where this feature flag can be managed. Will show up in Vercel Toolbar.
     */
    origin?: string;
    /**
     * A description of this feature flag. Will show up in Vercel Toolbar.
     */
    description?: string;
    /**
     * An array containing available options.
     *
     * * The returend value does not need to be declared in `options`, but it's recommended as all declared options show up in Vercel Toolbar.
     *
     * Value is required, but the label is optional.
     * @example `[{ label: "Off", value: false }, { label: "On", value: true }]`
     *
     * Non-objects like strings can be passed using shorthands which will be used as values without labels.
     * @example `["EUR", "USD"]`
     */
    options?: FlagOption<T>[];
    /**
     * This function is called when the feature flag is used (and no override is present) to return a value.
     */
    decide: Decide<T>;
};
type Flag<T extends JsonValue> = {
    (): Promise<T>;
    (code: string, precomputeFlags: readonly Flag<any>[], secret?: string): Promise<T>;
} & FlagMeta<T>;

/**
 * Returns the precomputation context of `precompute(flags, context)`
 */
declare function getPrecomputationContext<T>(): T;
type FlagsArray = readonly Flag<any>[];
type ValuesArray = readonly any[];
/**
 * Resolves a list of flags
 * @param flags - list of flags
 * @param context - optional context which will be accessible within a flag's `decide` function through `getPrecomputationContext`
 * @returns - an array of evaluated flag values with one entry per flag
 */
declare function evaluate<T extends FlagsArray>(flags: T, context?: any): Promise<{
    [K in keyof T]: Awaited<ReturnType<T[K]>>;
}>;
/**
 * Evaluate a list of feature flags and generate a signed string representing their values.
 *
 * This convenience function call combines `evaluate` and `serialize`.
 *
 * @param flags - list of flags
 * @param context - optional context which will be accessible within a flag's `decide` function through `getPrecomputationContext`
 * @returns - a string representing evaluated flags
 */
declare function precompute<T extends FlagsArray>(flags: T, context?: any): Promise<string>;
/**
 * Combines flag declarations with values.
 * @param flags - flag declarations
 * @param values - flag values
 * @returns - A record where the keys are flag keys and the values are flag values.
 */
declare function combine(flags: FlagsArray, values: ValuesArray): {
    [k: string]: any;
};
/**
 * Takes a list of feature flag declarations and their values and turns them into a short, signed string.
 *
 * The returned string is signed to avoid enumeration attacks.
 *
 * When a feature flag's `options` contains the value the flag resolved to, then the encoding will store it's index only, leading to better compression. Boolean values and null are compressed even when the options are not declared on the flag.
 *
 * @param flags - A list of feature flags
 * @param values - A list of the values of the flags declared in Â´flags`
 * @param secret - The secret to use for signing the result
 * @returns - A short string representing the values.
 */
declare function serialize(flags: FlagsArray, values: ValuesArray, secret?: string | undefined): Promise<string>;
/**
 * Decodes all flags given the list of flags used to encode. Returns an object consisting of each flag's key and its resolved value.
 * @param flags - Flags used when `code` was generated by `precompute` or `serialize`.
 * @param code - The code returned from `serialize`
 * @param secret - The secret to use for signing the result
 * @returns - An object consisting of each flag's key and its resolved value.
 */
declare function deserialize(flags: FlagsArray, code: string, secret?: string | undefined): Promise<Record<string, JsonValue>>;
/**
 * Decodes the value of one or multiple flags given the list of flags used to encode and the code.
 *
 * @param flag - Flag or list of flags to decode
 * @param precomputeFlags - Flags used when `code` was generated by `serialize`
 * @param code - The code returned from `serialize`
 * @param secret - The secret to use for verifying the signature
 */
declare function getPrecomputed<T extends JsonValue>(flag: Flag<T>, precomputeFlags: FlagsArray, code: string, secret?: string): Promise<T>;
/**
 * Decodes the value of one or multiple flags given the list of flags used to encode and the code.
 *
 * @param flag - Flag or list of flags to decode
 * @param precomputeFlags - Flags used when `code` was generated by `serialize`
 * @param code - The code returned from `serialize`
 * @param secret - The secret to use for verifying the signature
 */
declare function getPrecomputed<T extends JsonValue, K extends readonly Flag<T>[]>(flags: readonly [...K], precomputeFlags: FlagsArray, code: string, secret?: string): Promise<{
    [P in keyof K]: K[P] extends Flag<infer U> ? U : never;
}>;
/**
 * Generates all permutations given a list of feature flags based on the options declared on each flag.
 * @param flags - The list of feature flags
 * @param filter - An optional filter function which gets called with each permutation.
 * @param secret - The secret sign the generated permutation with
 * @returns An array of strings representing each permutation
 */
declare function generatePermutations(flags: FlagsArray, filter?: ((permutation: Record<string, JsonValue>) => boolean) | null, secret?: string): Promise<string[]>;

/**
 * Declares a feature flag.
 *
 * This a feature flag function. When that function is called it will call the flag's `decide` function and return the result.
 *
 * If an override set by Vercel Toolbar, or more precisely if the `vercel-flag-overrides` cookie, is present then the `decide` function will not be called and the value of the override will be returned instead.
 *
 * In both cases this function also calls the `reportValue` function of `@vercel/flags` so the evaluated flag shows up in Runtime Logs and is available for use with Web Analytics custom server-side events.
 *
 *
 * @param definition - Information about the feature flag.
 * @returns - A feature flag declaration
 */
declare function unstable_flag<T extends JsonValue>(definition: FlagDeclaration<T>): Flag<T>;
type KeyedFlagDefinitionType = {
    key: string;
} & FlagDefinitionType;
/**
 * Takes an object whose values are feature flag declarations and turns them into ProviderData which you can return from  `/.well-known/vercel/flags`.
 */
declare function unstable_getProviderData(flags: Record<string, KeyedFlagDefinitionType | readonly unknown[]>): ProviderData;

export { type Flag, type FlagDeclaration, combine as unstable_combine, deserialize as unstable_deserialize, evaluate as unstable_evaluate, unstable_flag, generatePermutations as unstable_generatePermutations, getPrecomputationContext as unstable_getPrecomputationContext, getPrecomputed as unstable_getPrecomputed, unstable_getProviderData, precompute as unstable_precompute, serialize as unstable_serialize };
