import {
  decrypt,
  reportValue
} from "../chunk-7GGUAVU6.js";

// src/next/index.ts
import { headers as getHeaders, cookies as getCookies } from "next/headers";

// src/next/overrides.ts
import { cookies } from "next/headers";

// src/next/async-memoize-one.ts
function memoizeOne(fn, isEqual, { cachePromiseRejection = false } = {}) {
  let calledOnce = false;
  let oldArgs;
  let lastResult;
  function memoized(...newArgs) {
    if (calledOnce && isEqual(newArgs, oldArgs))
      return lastResult;
    lastResult = fn.apply(this, newArgs);
    if (!cachePromiseRejection && lastResult.catch) {
      lastResult.catch(() => calledOnce = false);
    }
    calledOnce = true;
    oldArgs = newArgs;
    return lastResult;
  }
  return memoized;
}

// src/next/overrides.ts
var memoizedDecrypt = memoizeOne(
  (text) => decrypt(text),
  (a, b) => a[0] === b[0],
  // only the first argument gets compared
  { cachePromiseRejection: true }
);
async function getOverrides() {
  if (!process.env.FLAGS_SECRET) {
    console.warn(
      "@vercel/flags: Missing FLAGS_SECRET env var.",
      "Will not respect any overrides until this secret is added as an environment variable."
    );
    return null;
  }
  const cookieStore = await cookies();
  const cookie = cookieStore.get("vercel-flag-overrides")?.value;
  if (typeof cookie === "string" && cookie !== "") {
    const cookieOverrides = await memoizedDecrypt(cookie);
    return cookieOverrides ?? null;
  }
  return null;
}

// src/next/normalize-options.ts
function normalizeOptions(flagOptions) {
  if (!flagOptions) {
    return [{ value: false }, { value: true }];
  }
  return flagOptions.map((option) => {
    if (typeof option === "boolean")
      return { value: option };
    if (typeof option === "number")
      return { value: option };
    if (typeof option === "string")
      return { value: option };
    if (option === null)
      return { value: option };
    return option;
  });
}

// src/next/precompute.ts
import { AsyncLocalStorage } from "node:async_hooks";

// src/next/serialization.ts
import { CompactSign, base64url, compactVerify } from "jose";
var memoizedVerify = memoizeOne(
  (code, secret) => compactVerify(code, base64url.decode(secret), {
    algorithms: ["HS256"]
  }),
  (a, b) => a[0] === b[0] && a[1] === b[1],
  // only first two args matter
  { cachePromiseRejection: true }
);
var memoizedSign = memoizeOne(
  (uint8Array, secret) => new CompactSign(uint8Array).setProtectedHeader({ alg: "HS256" }).sign(base64url.decode(secret)),
  (a, b) => (
    // matchedIndices array must be equal
    a[0].length === b[0].length && a[0].every((v, i) => b[0][i] === v) && // secrets must be equal
    a[1] === b[1]
  ),
  { cachePromiseRejection: true }
);
function splitUint8Array(array, index) {
  const firstHalf = array.slice(0, index);
  const secondHalf = array.slice(index);
  return [firstHalf, secondHalf];
}
async function deserialize(code, flags, secret) {
  const { payload } = await memoizedVerify(code, secret);
  const [matchedIndicesArray, valuesUint8Array] = payload.length === flags.length ? [payload] : splitUint8Array(payload, flags.length);
  const valuesArray = valuesUint8Array ? (
    // re-add opening and closing brackets since we remove them when serializing
    JSON.parse(`[${new TextDecoder().decode(valuesUint8Array)}]`)
  ) : null;
  let spilled = 0;
  return matchedIndicesArray.reduce(
    (acc, valueIndex, index) => {
      const flag = flags[index];
      if (!flag) {
        throw new Error(`@vercel/flags: No flag at index ${index}`);
      }
      switch (valueIndex) {
        case 253 /* BOOLEAN_FALSE */:
          acc[flag.key] = false;
          break;
        case 254 /* BOOLEAN_TRUE */:
          acc[flag.key] = true;
          break;
        case 255 /* UNLISTED_VALUE */:
          acc[flag.key] = valuesArray[spilled++];
          break;
        case 252 /* NULL */:
          acc[flag.key] = null;
          break;
        default:
          acc[flag.key] = flag.options?.[valueIndex]?.value;
      }
      return acc;
    },
    {}
  );
}
var matchIndex = /* @__PURE__ */ function() {
  const stringifiedOptionsCache = /* @__PURE__ */ new Map();
  return function matchIndex2(options, value) {
    const t = typeof value;
    if (value === null || t === "boolean" || t === "string" || t === "number") {
      return options.findIndex((v) => v.value === value);
    }
    const stringifiedValue = JSON.stringify(value);
    let stringifiedOptions = stringifiedOptionsCache.get(options);
    if (!stringifiedOptions) {
      stringifiedOptions = options.map((o) => JSON.stringify(o.value));
      stringifiedOptionsCache.set(options, stringifiedOptions);
    }
    return stringifiedOptions.findIndex(
      (stringifiedOption) => stringifiedOption === stringifiedValue
    );
  };
}();
function joinUint8Arrays(array1, array2) {
  const combined = new Uint8Array(array1.length + array2.length);
  combined.set(array1);
  combined.set(array2, array1.length);
  return combined;
}
async function serialize(flagSet, flags, secret) {
  const unlistedValues = [];
  const matchedIndices = new Uint8Array(
    flags.map((flag) => {
      if (!flag.options) {
        throw new Error(
          `@vercel/flags: Flag ${flag.key} must declare options to be serializable`
        );
      }
      const value = flagSet[flag.key];
      if (!Object.prototype.hasOwnProperty.call(flagSet, flag.key) || value === void 0) {
        throw new Error(`@vercel/flags: Missing value for flag "${flag.key}"`);
      }
      switch (value) {
        case null:
          return 252 /* NULL */;
        case false:
          return 253 /* BOOLEAN_FALSE */;
        case true:
          return 254 /* BOOLEAN_TRUE */;
      }
      const matchedIndex = matchIndex(flag.options, value);
      if (matchedIndex > -1)
        return matchedIndex;
      unlistedValues.push(value);
      return 255 /* UNLISTED_VALUE */;
    })
  );
  let joined;
  if (unlistedValues.length > 0) {
    const jsonArray = new TextEncoder().encode(
      // slicing removes opening and closing array brackets as they'll always be
      //  there and we can re-add them when deserializing
      JSON.stringify(unlistedValues).slice(1, -1)
    );
    joined = joinUint8Arrays(matchedIndices, jsonArray);
  } else {
    joined = matchedIndices;
  }
  return memoizedSign(joined, secret);
}

// src/next/precompute.ts
var asyncLocalStorage = new AsyncLocalStorage();
function getPrecomputationContext() {
  return asyncLocalStorage.getStore();
}
async function evaluate(flags, context) {
  return asyncLocalStorage.run(context, () => {
    return Promise.all(flags.map((flag) => flag()));
  });
}
async function precompute(flags, context) {
  const values = await evaluate(flags, context);
  return serialize2(flags, values);
}
function combine(flags, values) {
  return Object.fromEntries(flags.map((flag, i) => [flag.key, values[i]]));
}
async function serialize2(flags, values, secret = process.env.FLAGS_SECRET) {
  if (!secret) {
    throw new Error("@vercel/flags: Can not serialize due to missing secret");
  }
  return serialize(combine(flags, values), flags, secret);
}
async function deserialize2(flags, code, secret = process.env.FLAGS_SECRET) {
  if (!secret) {
    throw new Error("@vercel/flags: Can not serialize due to missing secret");
  }
  return deserialize(code, flags, secret);
}
async function getPrecomputed(flagOrFlags, precomputeFlags, code, secret = process.env.FLAGS_SECRET) {
  const flagSet = await deserialize2(precomputeFlags, code, secret);
  if (Array.isArray(flagOrFlags)) {
    return flagOrFlags.map((flag) => flagSet[flag.key]);
  } else {
    return flagSet[flagOrFlags.key];
  }
}
function* cartesianIterator(items) {
  const remainder = items.length > 1 ? cartesianIterator(items.slice(1)) : [[]];
  for (let r of remainder)
    for (let h of items.at(0))
      yield [h, ...r];
}
async function generatePermutations(flags, filter = null, secret = process.env.FLAGS_SECRET) {
  const options = flags.map((flag) => {
    if (!flag.options) {
      throw new Error(`@vercel/flags: Flag ${flag.key} must declare options`);
    }
    return flag.options.map((option) => option.value);
  });
  const list = [];
  for (const permutation of cartesianIterator(options)) {
    const permObject = permutation.reduce(
      (acc, value, index) => {
        acc[flags[index].key] = value;
        return acc;
      },
      {}
    );
    if (!filter || filter(permObject))
      list.push(permObject);
  }
  return Promise.all(list.map((values) => serialize(values, flags, secret)));
}

// src/next/index.ts
var evaluationCache = /* @__PURE__ */ new WeakMap();
function getCachedValuePromise(headers, flagKey) {
  const map = evaluationCache.get(headers)?.get(flagKey);
  if (!map)
    return void 0;
  const context = getPrecomputationContext();
  return map.get(context);
}
function setCachedValuePromise(headers, flagKey, flagValue) {
  const context = getPrecomputationContext();
  const byHeaders = evaluationCache.get(headers);
  if (!byHeaders) {
    evaluationCache.set(
      headers,
      /* @__PURE__ */ new Map([[flagKey, /* @__PURE__ */ new Map([[context, flagValue]])]])
    );
    return;
  }
  const byFlagKey = byHeaders.get(flagKey);
  if (!byFlagKey) {
    byHeaders.set(flagKey, /* @__PURE__ */ new Map([[context, flagValue]]));
    return;
  }
  byFlagKey.set(context, flagValue);
}
function unstable_flag(definition) {
  const flag = async (code, precomputeFlags, secret = process.env.FLAGS_SECRET) => {
    if (code && precomputeFlags) {
      return getPrecomputed(flag, precomputeFlags, code, secret);
    }
    const [headers, cookies2] = await Promise.all([getHeaders(), getCookies()]);
    const overrides = await getOverrides();
    if (overrides && overrides[definition.key] !== void 0) {
      return Promise.resolve(overrides[definition.key]);
    }
    const cachedValue = getCachedValuePromise(headers, flag.key);
    if (cachedValue !== void 0) {
      reportValue(definition.key, cachedValue);
      return cachedValue;
    }
    let decisionPromise;
    try {
      decisionPromise = Promise.resolve(
        definition.decide({ headers, cookies: cookies2 })
      ).catch((error) => {
        if (definition.defaultValue !== void 0) {
          console.error(error);
          console.warn(
            `@vercel/flags: Flag "${definition.key}" is falling back to the defaultValue`
          );
          return definition.defaultValue;
        }
        console.warn(
          `@vercel/flags: Flag "${definition.key}" could not be evaluated`
        );
        throw error;
      });
    } catch (error) {
      if (definition.defaultValue !== void 0) {
        console.error(error);
        console.warn(
          `@vercel/flags: Flag "${definition.key}" is falling back to the defaultValue`
        );
        decisionPromise = Promise.resolve(definition.defaultValue);
      } else {
        console.warn(
          `@vercel/flags: Flag "${definition.key}" could not be evaluated`
        );
        throw error;
      }
    }
    setCachedValuePromise(headers, definition.key, decisionPromise);
    const decision = await decisionPromise;
    reportValue(definition.key, decision);
    return decision;
  };
  if (typeof definition.options === "undefined" && typeof definition.defaultValue !== "boolean" && definition.defaultValue !== void 0) {
    throw new Error(
      `@vercel/flags: options for flag "${definition.key}" are required for non-boolean defaultValue`
    );
  }
  flag.key = definition.key;
  flag.defaultValue = definition.defaultValue;
  flag.origin = definition.origin;
  flag.options = normalizeOptions(definition.options);
  flag.description = definition.description;
  flag.decide = definition.decide;
  return flag;
}
function unstable_getProviderData(flags) {
  const definitions = Object.values(flags).filter((i) => !Array.isArray(i)).reduce((acc, facet, index) => {
    acc[facet.key] = {
      options: facet.options,
      origin: facet.origin,
      description: facet.description
    };
    return acc;
  }, {});
  return { definitions, hints: [] };
}
export {
  combine as unstable_combine,
  deserialize2 as unstable_deserialize,
  evaluate as unstable_evaluate,
  unstable_flag,
  generatePermutations as unstable_generatePermutations,
  getPrecomputationContext as unstable_getPrecomputationContext,
  getPrecomputed as unstable_getPrecomputed,
  unstable_getProviderData,
  precompute as unstable_precompute,
  serialize2 as unstable_serialize
};
//# sourceMappingURL=index.js.map