{"version":3,"sources":["../../src/next/index.ts","../../src/next/overrides.ts","../../src/next/async-memoize-one.ts","../../src/next/normalize-options.ts","../../src/next/precompute.ts","../../src/next/serialization.ts"],"sourcesContent":["import { headers as getHeaders, cookies as getCookies } from 'next/headers';\nimport {\n  type FlagDefinitionType,\n  type ProviderData,\n  type JsonValue,\n  reportValue,\n  type FlagDefinitionsType,\n} from '..';\nimport type { FlagDeclaration, Flag } from './types';\nimport { getOverrides } from './overrides';\nimport { normalizeOptions } from './normalize-options';\nimport { getPrecomputationContext, getPrecomputed } from './precompute';\n\nexport type { Flag, FlagDeclaration } from './types';\n\nexport {\n  getPrecomputed as unstable_getPrecomputed,\n  combine as unstable_combine,\n  serialize as unstable_serialize,\n  deserialize as unstable_deserialize,\n  getPrecomputationContext as unstable_getPrecomputationContext,\n  evaluate as unstable_evaluate,\n  precompute as unstable_precompute,\n  generatePermutations as unstable_generatePermutations,\n} from './precompute';\n\n// a map of (headers, flagKey, context) => value\nconst evaluationCache = new WeakMap<\n  Headers,\n  Map</* flagKey */ string, Map</* context */ any, any>>\n>();\n\nfunction getCachedValuePromise(headers: Headers, flagKey: string): any {\n  const map = evaluationCache.get(headers)?.get(flagKey);\n  if (!map) return undefined;\n  const context = getPrecomputationContext();\n  return map.get(context);\n}\n\nfunction setCachedValuePromise(\n  headers: Headers,\n  flagKey: string,\n  flagValue: any,\n): any {\n  const context = getPrecomputationContext();\n  const byHeaders = evaluationCache.get(headers);\n\n  if (!byHeaders) {\n    evaluationCache.set(\n      headers,\n      new Map([[flagKey, new Map([[context, flagValue]])]]),\n    );\n    return;\n  }\n\n  const byFlagKey = byHeaders.get(flagKey);\n  if (!byFlagKey) {\n    byHeaders.set(flagKey, new Map([[context, flagValue]]));\n    return;\n  }\n\n  byFlagKey.set(context, flagValue);\n}\n\n/**\n * Declares a feature flag.\n *\n * This a feature flag function. When that function is called it will call the flag's `decide` function and return the result.\n *\n * If an override set by Vercel Toolbar, or more precisely if the `vercel-flag-overrides` cookie, is present then the `decide` function will not be called and the value of the override will be returned instead.\n *\n * In both cases this function also calls the `reportValue` function of `@vercel/flags` so the evaluated flag shows up in Runtime Logs and is available for use with Web Analytics custom server-side events.\n *\n *\n * @param definition - Information about the feature flag.\n * @returns - A feature flag declaration\n */\nexport function unstable_flag<T extends JsonValue>(\n  definition: FlagDeclaration<T>,\n): Flag<T> {\n  // use cache to guarantee flags only decide once per request\n\n  const flag: Flag<T> = async (\n    code?: string,\n    precomputeFlags?: readonly Flag<any>[],\n    secret: string | undefined = process.env.FLAGS_SECRET,\n  ) => {\n    if (code && precomputeFlags) {\n      return getPrecomputed(flag, precomputeFlags, code, secret);\n    }\n\n    const [headers, cookies] = await Promise.all([getHeaders(), getCookies()]);\n\n    // PERF this currently decrypts on every flag use, could use LRU cache\n    const overrides = await getOverrides();\n\n    if (overrides && overrides[definition.key] !== undefined) {\n      return Promise.resolve(overrides[definition.key] as T);\n    }\n\n    // check cache\n    const cachedValue = getCachedValuePromise(headers, flag.key);\n    if (cachedValue !== undefined) {\n      reportValue(definition.key, cachedValue);\n      return cachedValue;\n    }\n\n    // fall back to defaultValue if it is set\n    let decisionPromise: Promise<T> | T;\n    try {\n      decisionPromise = Promise.resolve<T>(\n        definition.decide({ headers, cookies }),\n      )\n        // catch errors in async \"decide\" functions\n        .catch<T>((error: Error) => {\n          // try to recover if defaultValue is set\n          if (definition.defaultValue !== undefined) {\n            console.error(error);\n            console.warn(\n              `@vercel/flags: Flag \"${definition.key}\" is falling back to the defaultValue`,\n            );\n            return definition.defaultValue;\n          }\n          console.warn(\n            `@vercel/flags: Flag \"${definition.key}\" could not be evaluated`,\n          );\n          throw error;\n        });\n    } catch (error) {\n      // catch errors in sync \"decide\" functions\n      if (definition.defaultValue !== undefined) {\n        console.error(error);\n        console.warn(\n          `@vercel/flags: Flag \"${definition.key}\" is falling back to the defaultValue`,\n        );\n        decisionPromise = Promise.resolve(definition.defaultValue);\n      } else {\n        console.warn(\n          `@vercel/flags: Flag \"${definition.key}\" could not be evaluated`,\n        );\n        throw error;\n      }\n    }\n\n    setCachedValuePromise(headers, definition.key, decisionPromise);\n\n    const decision = await decisionPromise;\n    reportValue(definition.key, decision);\n    return decision;\n  };\n\n  // ensure we don't auto-infer boolean options when the default is not boolean\n  if (\n    typeof definition.options === 'undefined' &&\n    typeof definition.defaultValue !== 'boolean' &&\n    definition.defaultValue !== undefined\n  ) {\n    throw new Error(\n      `@vercel/flags: options for flag \"${definition.key}\" are required for non-boolean defaultValue`,\n    );\n  }\n\n  flag.key = definition.key;\n  flag.defaultValue = definition.defaultValue;\n  flag.origin = definition.origin;\n  flag.options = normalizeOptions<T>(definition.options);\n  flag.description = definition.description;\n  flag.decide = definition.decide;\n\n  return flag;\n}\n\ntype KeyedFlagDefinitionType = { key: string } & FlagDefinitionType;\n\n/**\n * Takes an object whose values are feature flag declarations and turns them into ProviderData which you can return from  `/.well-known/vercel/flags`.\n */\nexport function unstable_getProviderData(\n  flags: Record<\n    string,\n    // accept an unknown array\n    KeyedFlagDefinitionType | readonly unknown[]\n  >,\n): ProviderData {\n  const definitions = Object.values(flags)\n    // filter out precomputed arrays\n    .filter((i): i is KeyedFlagDefinitionType => !Array.isArray(i))\n    .reduce<FlagDefinitionsType>((acc, facet, index) => {\n      // maps the existing type from the facet definitions to the type\n      // the toolbar expects\n      acc[facet.key] = {\n        options: facet.options,\n        origin: facet.origin,\n        description: facet.description,\n      };\n      return acc;\n    }, {});\n  return { definitions, hints: [] };\n}\n","import { type FlagOverridesType, decrypt } from '..';\nimport { cookies } from 'next/headers';\nimport { memoizeOne } from './async-memoize-one';\n\nconst memoizedDecrypt = memoizeOne(\n  (text: string) => decrypt<FlagOverridesType>(text),\n  (a, b) => a[0] === b[0], // only the first argument gets compared\n  { cachePromiseRejection: true },\n);\n\nexport async function getOverrides() {\n  // TODO defining flags should already throw since a FLAGS_SECRET is necessary for\n  // encrypting the flag code\n  if (!process.env.FLAGS_SECRET) {\n    console.warn(\n      '@vercel/flags: Missing FLAGS_SECRET env var.',\n      'Will not respect any overrides until this secret is added as an environment variable.',\n    );\n    return null;\n  }\n\n  const cookieStore = await cookies();\n  const cookie = cookieStore.get('vercel-flag-overrides')?.value;\n  if (typeof cookie === 'string' && cookie !== '') {\n    const cookieOverrides = await memoizedDecrypt(cookie);\n    return cookieOverrides ?? null;\n  }\n\n  return null;\n}\n","// adapted from https://github.com/microlinkhq/async-memoize-one\n// and https://github.com/alexreardon/memoize-one\n\ntype MemoizeOneOptions = {\n  cachePromiseRejection?: boolean;\n};\n\ntype MemoizedFn<TFunc extends (this: any, ...args: any[]) => any> = (\n  this: ThisParameterType<TFunc>,\n  ...args: Parameters<TFunc>\n) => ReturnType<TFunc>;\n\n/**\n * Memoizes an async function, but only keeps the latest result\n */\nexport function memoizeOne<TFunc extends (this: any, ...newArgs: any[]) => any>(\n  fn: TFunc,\n  isEqual: (a: Parameters<TFunc>, b: Parameters<TFunc>) => boolean,\n  { cachePromiseRejection = false }: MemoizeOneOptions = {},\n): MemoizedFn<TFunc> {\n  let calledOnce = false;\n  let oldArgs: Parameters<TFunc>;\n  let lastResult: any;\n\n  function memoized(\n    this: ThisParameterType<TFunc>,\n    ...newArgs: Parameters<TFunc>\n  ) {\n    if (calledOnce && isEqual(newArgs, oldArgs)) return lastResult;\n\n    lastResult = fn.apply(this, newArgs);\n\n    if (!cachePromiseRejection && lastResult.catch) {\n      lastResult.catch(() => (calledOnce = false));\n    }\n\n    calledOnce = true;\n    oldArgs = newArgs;\n\n    return lastResult;\n  }\n\n  return memoized;\n}\n","import type { FlagOption, GenerousOption } from './types';\n\nexport function normalizeOptions<T>(\n  flagOptions: GenerousOption<T>[] | undefined,\n): FlagOption<T>[] {\n  if (!flagOptions) {\n    return [{ value: false }, { value: true }] as FlagOption<T>[];\n  }\n\n  return flagOptions.map((option) => {\n    if (typeof option === 'boolean') return { value: option };\n    if (typeof option === 'number') return { value: option };\n    if (typeof option === 'string') return { value: option };\n    if (option === null) return { value: option };\n\n    return option;\n  }) as FlagOption<T>[];\n}\n","import { AsyncLocalStorage } from 'node:async_hooks';\nimport { Flag } from './types';\nimport type { JsonValue } from '..';\nimport * as s from './serialization';\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\n/**\n * Returns the precomputation context of `precompute(flags, context)`\n */\nexport function getPrecomputationContext<T>() {\n  return asyncLocalStorage.getStore() as T;\n}\n\ntype FlagsArray = readonly Flag<any>[];\ntype ValuesArray = readonly any[];\n\n/**\n * Resolves a list of flags\n * @param flags - list of flags\n * @param context - optional context which will be accessible within a flag's `decide` function through `getPrecomputationContext`\n * @returns - an array of evaluated flag values with one entry per flag\n */\nexport async function evaluate<T extends FlagsArray>(\n  flags: T,\n  context?: any,\n): Promise<{ [K in keyof T]: Awaited<ReturnType<T[K]>> }> {\n  return asyncLocalStorage.run(context, () => {\n    return Promise.all(flags.map((flag) => flag())) as Promise<{\n      [K in keyof T]: Awaited<ReturnType<T[K]>>;\n    }>;\n  });\n}\n\n/**\n * Evaluate a list of feature flags and generate a signed string representing their values.\n *\n * This convenience function call combines `evaluate` and `serialize`.\n *\n * @param flags - list of flags\n * @param context - optional context which will be accessible within a flag's `decide` function through `getPrecomputationContext`\n * @returns - a string representing evaluated flags\n */\nexport async function precompute<T extends FlagsArray>(\n  flags: T,\n  context?: any,\n): Promise<string> {\n  const values = await evaluate(flags, context);\n  return serialize(flags, values);\n}\n\n/**\n * Combines flag declarations with values.\n * @param flags - flag declarations\n * @param values - flag values\n * @returns - A record where the keys are flag keys and the values are flag values.\n */\nexport function combine(flags: FlagsArray, values: ValuesArray) {\n  return Object.fromEntries(flags.map((flag, i) => [flag.key, values[i]]));\n}\n\n/**\n * Takes a list of feature flag declarations and their values and turns them into a short, signed string.\n *\n * The returned string is signed to avoid enumeration attacks.\n *\n * When a feature flag's `options` contains the value the flag resolved to, then the encoding will store it's index only, leading to better compression. Boolean values and null are compressed even when the options are not declared on the flag.\n *\n * @param flags - A list of feature flags\n * @param values - A list of the values of the flags declared in Â´flags`\n * @param secret - The secret to use for signing the result\n * @returns - A short string representing the values.\n */\nexport async function serialize(\n  flags: FlagsArray,\n  values: ValuesArray,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n) {\n  if (!secret) {\n    throw new Error('@vercel/flags: Can not serialize due to missing secret');\n  }\n\n  return s.serialize(combine(flags, values), flags, secret);\n}\n\n/**\n * Decodes all flags given the list of flags used to encode. Returns an object consisting of each flag's key and its resolved value.\n * @param flags - Flags used when `code` was generated by `precompute` or `serialize`.\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for signing the result\n * @returns - An object consisting of each flag's key and its resolved value.\n */\nexport async function deserialize(\n  flags: FlagsArray,\n  code: string,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n) {\n  if (!secret) {\n    throw new Error('@vercel/flags: Can not serialize due to missing secret');\n  }\n\n  return s.deserialize(code, flags, secret);\n}\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<T extends JsonValue>(\n  flag: Flag<T>,\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret?: string,\n): Promise<T>;\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<\n  T extends JsonValue,\n  K extends readonly Flag<T>[],\n>(\n  flags: readonly [...K],\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret?: string,\n): Promise<{ [P in keyof K]: K[P] extends Flag<infer U> ? U : never }>;\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<T extends JsonValue>(\n  flagOrFlags: Flag<T> | readonly Flag<T>[],\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n): Promise<any> {\n  const flagSet = await deserialize(precomputeFlags, code, secret);\n\n  if (Array.isArray(flagOrFlags)) {\n    // Handle case when an array of flags is passed\n    return flagOrFlags.map((flag) => flagSet[flag.key]);\n  } else {\n    // Handle case when a single flag is passed\n    return flagSet[(flagOrFlags as Flag<T>).key];\n  }\n}\n\n// see https://stackoverflow.com/a/44344803\nfunction* cartesianIterator<T>(items: T[][]): Generator<T[]> {\n  const remainder = items.length > 1 ? cartesianIterator(items.slice(1)) : [[]];\n  for (let r of remainder) for (let h of items.at(0)!) yield [h, ...r];\n}\n\n/**\n * Generates all permutations given a list of feature flags based on the options declared on each flag.\n * @param flags - The list of feature flags\n * @param filter - An optional filter function which gets called with each permutation.\n * @param secret - The secret sign the generated permutation with\n * @returns An array of strings representing each permutation\n */\nexport async function generatePermutations(\n  flags: FlagsArray,\n  filter: ((permutation: Record<string, JsonValue>) => boolean) | null = null,\n  secret: string = process.env.FLAGS_SECRET!,\n): Promise<string[]> {\n  const options = flags.map((flag) => {\n    if (!flag.options) {\n      throw new Error(`@vercel/flags: Flag ${flag.key} must declare options`);\n    }\n\n    return flag.options.map((option) => option.value);\n  });\n\n  const list: Record<string, JsonValue>[] = [];\n\n  for (const permutation of cartesianIterator(options)) {\n    const permObject = permutation.reduce<Record<string, JsonValue>>(\n      (acc, value, index) => {\n        acc[flags[index]!.key] = value;\n        return acc;\n      },\n      {},\n    );\n    if (!filter || filter(permObject)) list.push(permObject);\n  }\n\n  return Promise.all(list.map((values) => s.serialize(values, flags, secret)));\n}\n","import type { JsonValue } from '..';\nimport { memoizeOne } from './async-memoize-one';\nimport type { FlagOption, Flag } from './types';\nimport { CompactSign, base64url, compactVerify } from 'jose';\n\n// 252 max options length allows storing index  0 to 251,\n// so 252 is the first SPECIAL_INTEGER\nexport const MAX_OPTION_LENGTH = 252;\n\nenum SPECIAL_INTEGERS {\n  /** Signals that the returned value is not listed in the flag's options */\n  NULL = 252,\n  BOOLEAN_FALSE = 253,\n  BOOLEAN_TRUE = 254,\n  UNLISTED_VALUE = 255,\n}\n\nconst memoizedVerify = memoizeOne(\n  (code: string, secret: string) =>\n    compactVerify(code, base64url.decode(secret), {\n      algorithms: ['HS256'],\n    }),\n  (a, b) => a[0] === b[0] && a[1] === b[1], // only first two args matter\n  { cachePromiseRejection: true },\n);\n\nconst memoizedSign = memoizeOne(\n  (uint8Array: Uint8Array, secret) =>\n    new CompactSign(uint8Array)\n      .setProtectedHeader({ alg: 'HS256' })\n      .sign(base64url.decode(secret)),\n  (a, b) =>\n    // matchedIndices array must be equal\n    a[0].length === b[0].length &&\n    a[0].every((v, i) => b[0][i] === v) &&\n    // secrets must be equal\n    a[1] === b[1],\n  { cachePromiseRejection: true },\n);\n\nfunction splitUint8Array(\n  array: Uint8Array,\n  index: number,\n): [Uint8Array, Uint8Array] {\n  const firstHalf = array.slice(0, index);\n  const secondHalf = array.slice(index);\n  return [firstHalf, secondHalf];\n}\n\nexport async function deserialize(\n  code: string,\n  flags: readonly Flag<any>[],\n  secret: string,\n): Promise<Record<string, JsonValue>> {\n  // TODO what happens when verification fails?\n  const { payload } = await memoizedVerify(code, secret);\n\n  const [matchedIndicesArray, valuesUint8Array] =\n    payload.length === flags.length\n      ? [payload]\n      : splitUint8Array(payload, flags.length);\n\n  const valuesArray = valuesUint8Array\n    ? // re-add opening and closing brackets since we remove them when serializing\n      JSON.parse(`[${new TextDecoder().decode(valuesUint8Array)}]`)\n    : null;\n\n  let spilled = 0;\n  return matchedIndicesArray.reduce<Record<string, JsonValue>>(\n    (acc, valueIndex, index) => {\n      const flag = flags[index];\n\n      if (!flag) {\n        throw new Error(`@vercel/flags: No flag at index ${index}`);\n      }\n\n      switch (valueIndex) {\n        case SPECIAL_INTEGERS.BOOLEAN_FALSE:\n          acc[flag.key] = false;\n          break;\n        case SPECIAL_INTEGERS.BOOLEAN_TRUE:\n          acc[flag.key] = true;\n          break;\n        case SPECIAL_INTEGERS.UNLISTED_VALUE:\n          acc[flag.key] = valuesArray[spilled++];\n          break;\n        case SPECIAL_INTEGERS.NULL:\n          acc[flag.key] = null;\n          break;\n        default:\n          acc[flag.key] = flag.options?.[valueIndex]?.value as JsonValue;\n      }\n\n      return acc;\n    },\n    {},\n  );\n}\n\n/**\n * When serializing flags we find the matching option index for each evaluated value.\n *\n * This means we potentially need to iterate through all options of all flags.\n *\n * When the value we're trying to match is a literal (bool, string, number)\n * we look for it using referntial equality.\n *\n * When the value is an array or object we stringify the value and we stringify\n * the options of each flag and then we search for it by string comparison.\n *\n * This is faster than doing a deep equality check and also allows us not to\n * use any external library.\n *\n * We also cache the result of stringifying all options so in a Map so we only\n * ever need to stringify them once.\n */\nconst matchIndex = (function () {\n  const stringifiedOptionsCache = new Map<FlagOption<any>[], string[]>();\n  return function matchIndex(options: FlagOption<any>[], value: JsonValue) {\n    const t = typeof value;\n\n    // we're looking for a literal value, so we can check using referntial equality\n    if (value === null || t === 'boolean' || t === 'string' || t === 'number') {\n      return options.findIndex((v) => v.value === value);\n    }\n\n    // we're looking for an array or object, so we should check stringified\n    const stringifiedValue = JSON.stringify(value);\n    let stringifiedOptions = stringifiedOptionsCache.get(options);\n    if (!stringifiedOptions) {\n      stringifiedOptions = options.map((o) => JSON.stringify(o.value));\n      stringifiedOptionsCache.set(options, stringifiedOptions);\n    }\n\n    return stringifiedOptions.findIndex(\n      (stringifiedOption) => stringifiedOption === stringifiedValue,\n    );\n  };\n})();\n\nfunction joinUint8Arrays(array1: Uint8Array, array2: Uint8Array): Uint8Array {\n  const combined = new Uint8Array(array1.length + array2.length);\n  combined.set(array1);\n  combined.set(array2, array1.length);\n  return combined;\n}\nexport async function serialize(\n  flagSet: Record<Flag<any>['key'], JsonValue>,\n  flags: readonly Flag<any>[],\n  secret: string,\n) {\n  const unlistedValues: JsonValue[] = [];\n\n  const matchedIndices = new Uint8Array(\n    flags.map((flag) => {\n      if (!flag.options) {\n        throw new Error(\n          `@vercel/flags: Flag ${flag.key} must declare options to be serializable`,\n        );\n      }\n\n      const value = flagSet[flag.key];\n      if (\n        !Object.prototype.hasOwnProperty.call(flagSet, flag.key) ||\n        value === undefined\n      ) {\n        throw new Error(`@vercel/flags: Missing value for flag \"${flag.key}\"`);\n      }\n\n      // avoid searching for common values\n      // and ensure they can always be compressed, even if not listed in options\n      switch (value) {\n        case null:\n          return SPECIAL_INTEGERS.NULL;\n        case false:\n          return SPECIAL_INTEGERS.BOOLEAN_FALSE;\n        case true:\n          return SPECIAL_INTEGERS.BOOLEAN_TRUE;\n      }\n\n      const matchedIndex = matchIndex(flag.options, value);\n      if (matchedIndex > -1) return matchedIndex;\n\n      // value was not listed in options, so we need to\n      // transport it using JSON.stringify(). we return 255 to\n      // indicate this value is stringified.\n      // stringified values will be placed at the end of the\n      // indices array\n      unlistedValues.push(value);\n      return SPECIAL_INTEGERS.UNLISTED_VALUE;\n    }),\n  );\n\n  let joined: Uint8Array;\n  // there were unlisted values, so we need to join arrays\n  if (unlistedValues.length > 0) {\n    const jsonArray = new TextEncoder().encode(\n      // slicing removes opening and closing array brackets as they'll always be\n      //  there and we can re-add them when deserializing\n      JSON.stringify(unlistedValues).slice(1, -1),\n    );\n    joined = joinUint8Arrays(matchedIndices, jsonArray);\n  } else {\n    joined = matchedIndices;\n  }\n\n  return memoizedSign(joined, secret);\n}\n"],"mappings":"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","names":["matchIndex","serialize","deserialize","cookies"]}