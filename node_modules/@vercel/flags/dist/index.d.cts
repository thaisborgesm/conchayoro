/**
 * Data flag providers can return to integrate with the toolbar.
 */
type ProviderData = {
  definitions: FlagDefinitionsType;
  hints: { key: string; text: string }[];
};

/**
 * Data returned by the .well-known/vercel/flags API Route which the toolbar understands.
 */
type ApiData = {
    /**
     * Metadata about your application's feature flags
     */
    definitions?: FlagDefinitionsType;
    /**
     * Hints show up in the toolbar. They are meant to be used in case loading
     * data from your flag provider fails. For example when the provider fails to
     * responed or the configuration is invalid due to a missing environment variable.
     */
    hints?: ProviderData['hints'];
    /**
     * Sets the encryption mode for the vercel-flag-overrides cookie
     * - when set to "encrypted" the toolbar will store encrypted overrides
     * - when set to "plaintext" the toolbar will store plaintext overrides
     */
    overrideEncryptionMode?: 'encrypted' | 'plaintext';
};
type JsonArray = ReadonlyArray<JsonValue>;
type JsonValue = string | boolean | number | null | JsonArray | {
    [key: string]: JsonValue;
};
interface FlagOptionType {
    value: JsonValue;
    label?: string;
}
interface FlagDefinitionType {
    options?: FlagOptionType[];
    /**
     * The URL where the feature flag can be managed.
     */
    origin?: string;
    description?: string;
}
/**
 * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.
 *
 * This function is just like JSON.stringify but also escapes the resulting string to prevent XSS.
 *
 * @see https://pragmaticwebsecurity.com/articles/spasecurity/json-stringify-xss
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 */
declare function safeJsonStringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
/**
 * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.
 *
 * This function is just like JSON.stringify but also escapes the resulting string to prevent XSS.
 *
 * @see https://pragmaticwebsecurity.com/articles/spasecurity/json-stringify-xss
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer An array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 */
declare function safeJsonStringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;
/**
 * Definitions of a feature flags.
 *
 * Definitions are data like the description, available options, or its origin.
 */
type FlagDefinitionsType = Record<string, FlagDefinitionType>;
/**
 * Values of feature flags.
 *
 * This record consists of key-value pairs of flag keys and the value they resolved to.
 */
type FlagValuesType = Record<string, JsonValue>;
/**
 * Overrides of feature flags.
 *
 * This record consists of key-value pairs of flag keys and the override to be used for them.
 */
type FlagOverridesType = Record<string, JsonValue>;
/**
 * Function to encrypt overrides, values, definitions, and API data.
 */
declare function encrypt<T extends object>(value: T, secret?: string | undefined): Promise<string>;
/**
 * Function to decrypt overrides, values, definitions, and API data.
 */
declare function decrypt<T extends object>(encryptedData: string, secret?: string | undefined): Promise<T | undefined>;
/**
 * This function lets you verify whether a request to your application's .well-known/vercel/flags endpoint was made by the toolbar.
 * You can use verifyAccess to keep this endpoint private, to avoid public access of your feature flag definitions through that endpoint.
 *
 * @example Using verifyAccess in .well-known/vercel/flags to verify access and respond with unencrypted data.
 * ```
 *  import { type NextRequest, NextResponse } from "next/server";
 *  import { verifyAccess } from "@vercel/flags";
 *
 *  export async function GET(request: NextRequest) {
 *    const access = await verifyAccess(request.headers.get("Authorization"));
 *    if (!access) return NextResponse.json(null, { status: 401 });
 *
 *    return NextResponse.json({ definitions: {} })
 *  }
 * ```
 * @param authHeader the Authorization header to check
 * @param secret the FLAGS_SECRET
 * @returns True when the authorization header was valid
 */
declare function verifyAccess(authHeader: string | null | undefined, secret?: string | undefined): Promise<boolean>;
/**
 * This function lets you report the value of a resolved flag, which will make it available when viewing Monitoring, Logs, Analytics and Speed Insights on Vercel.
 * It's important to note that this only has effects when running on Vercel in a preview or production environments, but not during local development.
 *
 * @example Using `reportValue` to report a flag value.
 * ```
 *  import { type NextRequest, NextResponse } from "next/server";
 *  import { reportValue } from '@vercel/flags';
 *
 *  export async function GET(request: NextRequest) {
 *    reportValue('my-flag', true);
 *    return NextResponse.json({});
 *  }
 * ```
 *
 * @param key the name of the flag
 * @param value the resolved value of the flag
 */
declare function reportValue(key: string, value: unknown): void;

export { type ApiData, type FlagDefinitionType, type FlagDefinitionsType, type FlagOverridesType, type FlagValuesType, type JsonValue, type ProviderData, decrypt, encrypt, reportValue, safeJsonStringify, verifyAccess };
