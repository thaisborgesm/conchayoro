"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/providers/statsig.ts
async function getStatsigData(options) {
  const hints = [];
  if (!options.consoleApiKey) {
    hints.push({
      key: "statsig/missing-api-key",
      text: "Missing Statsig Console API Key"
    });
  }
  if (hints.length > 0)
    return { definitions: {}, hints };
  const [gates, experiments] = await Promise.allSettled([
    getFeatureGates(options),
    getExperiments(options)
  ]);
  const definitions = {};
  if (gates.status === "fulfilled") {
    gates.value.forEach((gate) => {
      definitions[gate.id] = {
        description: gate.description,
        origin: options.projectId ? `https://console.statsig.com/${options.projectId}/gates/${gate.id}` : void 0,
        options: [
          { label: "Off", value: false },
          { label: "On", value: true }
        ]
      };
    });
  } else {
    hints.push({
      key: "statsig/failed-to-load-feature-gates",
      text: gates.reason.message
    });
  }
  if (experiments.status === "fulfilled") {
    experiments.value.forEach((experiment) => {
      definitions[experiment.id] = {
        description: experiment.description,
        origin: options.projectId ? `https://console.statsig.com/${options.projectId}/experiments/${experiment.id}/setup` : void 0,
        options: experiment.groups.map((group) => {
          return {
            label: group.name,
            value: group.parameterValues
          };
        })
      };
    });
  } else {
    hints.push({
      key: "statsig/failed-to-load-experiments",
      text: experiments.reason.message
    });
  }
  return { definitions, hints };
}
async function getFeatureGates(options) {
  const data = [];
  let suffix = "/console/v1/gates";
  do {
    const response = await fetch(`https://statsigapi.net${suffix}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        "STATSIG-API-KEY": options.consoleApiKey
      },
      cache: "no-store"
    });
    if (response.status !== 200) {
      await response.arrayBuffer();
      throw new Error(
        `Failed to fetch Statsig (Received ${response.status} response)`
      );
    }
    const body = await response.json();
    suffix = _optionalChain([body, 'access', _ => _.pagination, 'optionalAccess', _2 => _2.nextPage]) || null;
    data.push(...body.data);
  } while (suffix);
  return data;
}
async function getExperiments(options) {
  const data = [];
  let suffix = "/console/v1/experiments";
  do {
    const response = await fetch(`https://statsigapi.net${suffix}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        "STATSIG-API-KEY": options.consoleApiKey
      },
      cache: "no-store"
    });
    if (response.status !== 200) {
      await response.arrayBuffer();
      throw new Error(
        `Failed to fetch Statsig (Received ${response.status} response)`
      );
    }
    const body = await response.json();
    suffix = _optionalChain([body, 'access', _3 => _3.pagination, 'optionalAccess', _4 => _4.nextPage]) || null;
    data.push(...body.data);
  } while (suffix);
  return data;
}


exports.getStatsigData = getStatsigData;
//# sourceMappingURL=statsig.cjs.map